package BostonianCode;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;

public class Lexer
{

	int charClass;
	String lexeme;
	char nextChar;
	int token;
	int nextToken;
	File file;
	FileReader inputStream = null;

	public static final int LETTER = 1;
	public static final int DIGIT = 2;
	public static final int UNKNOWN = 99;

	public static final int INT_LIT = 10;
	public static final int IDENT = 11;
	public static final int ASSIGN_OP = 20;
	public static final int ADD_OP = 21;
	public static final int SUB_OP = 22;
	public static final int MULT_OP = 23;
	public static final int DIV_OP = 24;
	public static final int LEFT_PAREN = 25;
	public static final int RIGHT_PAREN = 26;
	public static final int EOF = -1;
	public static final int LEFT_Bracket;
	public static final int Right_Bracket;
	public static final int greater_than;
	pubic static final int less_than;


	/*****************************************************/
	/*
	 * getChar - a function to get the next character of 
	 * input and determine its character class
	 */
	public void getChar() 
	{
		
		int test = 0;

		try {

			if ((test = inputStream.read()) != EOF) 
			{
				nextChar = (char) test;
				
				if (Character.isAlphabetic(nextChar))
					charClass = LETTER;
				else if (Character.isDigit(nextChar))
					charClass = DIGIT;
				else
					charClass = UNKNOWN;
			}
			else
				charClass = EOF;
		} catch (IOException e) 
		{
			e.printStackTrace();
		}
	}

	/*****************************************************/
	/* lex - a simple lexical analyzer for arithmetic expressions */
	public int lex() 
	{
		lexeme = "";
		getNonBlank();
		
		switch (charClass) 
		{
			/* Parse identifiers */
			case LETTER:
				addChar();
				getChar();
				while (charClass == LETTER || charClass == DIGIT) 
				{
					addChar();
					getChar();
				}
				nextToken = IDENT;
				break;
				
			/* Parse integer literals */
			case DIGIT:
				addChar();
				getChar();
				while (charClass == DIGIT) 
				{
					addChar();
					getChar();
				}
				nextToken = INT_LIT;
				break;
				
			/* Parentheses and operators */
			case UNKNOWN:
				lookup(nextChar);
				getChar();
				break;
				
			/* EOF */
			default:
				nextToken = EOF;
				lexeme = "EOF";
				break;
		} /* End of switch */
			
		System.out.println("Next token is: " + nextToken + " | Next lexeme is " + lexeme);
		return nextToken;
		
	} /* End of function lex */
	
	/*****************************************************/
	/*
	 * lookup - a function to lookup operators and parentheses and return the token
	 */
	int lookup(char ch) 
	{
		switch (ch) 
		{
			case '(':
				addChar();
				nextToken = LEFT_PAREN;
				break;
			case ')':
				addChar();
				nextToken = RIGHT_PAREN;
				break;
			case '+':
				addChar();
				nextToken = ADD_OP;
				break;
			case '-':
				addChar();
				nextToken = SUB_OP;
				break;
			case '*':
				addChar();
				nextToken = MULT_OP;
				break;
			case '/':
				addChar();
				nextToken = DIV_OP;
				break;
			default:
				addChar();
				nextToken = EOF;
				break;
		}
		return nextToken;
	}

	/*****************************************************/
	/* addChar - a function to add nextChar to lexeme */
	public void addChar() 
	{
		// Let's me have a name 100 characters long
		if (lexeme.length() <= 99) 
		{
			lexeme += nextChar;
		} else
		{
			System.out.println("Error - lexeme is too long \n");
			System.exit(0);
		}
	}

	/*****************************************************/
	/*
	 * getNonBlank - a function to call getChar until it returns a
	 * non-whitespace character
	 */
	public void getNonBlank() 
	{
		while (nextChar == ' ' || nextChar == '\r' || nextChar == '\n')
		{
			if(nextChar == '\n' || nextChar == '\r')
			{
				System.out.println();
			}
			getChar();
		}
	}
}
